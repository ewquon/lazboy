from __future__ import print_function
import os
import yaml

mypath = os.path.dirname(os.path.realpath(__file__))

def get_templates():
    dpath = os.path.join(mypath, 'simulation_templates')
    listing = os.listdir(dpath)
    templates = { os.path.splitext(name)[0]: os.path.join(dpath,name)
                    for name in listing
                    if os.path.isfile(os.path.join(dpath,name))
                        and name.endswith('.yaml') }

    listing = os.listdir(os.getcwd())
    custom_configs = { os.path.splitext(name)[0]: os.path.join(os.getcwd(),name)
                        for name in listing
                        if os.path.isfile(name) and name.endswith('.yaml') }
    print('Local configuration(s):',custom_configs)

    return templates, custom_configs

def read_template(fpath):
    #fpath = os.path.join(mypath, 'simulation_templates', name+'.yaml')
    print('Loaded template: '+fpath)
    with open(fpath,'r') as f:
        params = yaml.load(f)
    return params

def save_template(name):
    fpath = os.path.join(mypath, 'simulation_templates', name)
    if os.path.isfile(fpath):
        print('Template '+name+' already exists! No file was written.')
        return

def copy_and_update(srcdir,destdir,relpath,updatedict):
    srcpath = os.path.join(srcdir,relpath)
    destpath = os.path.join(destdir,relpath)
    with open(srcpath,'r') as f:
        content = f.read()
    content = content.format(**updatedict)
    with open(destpath,'w') as f:
        f.write(content)
    print('Wrote out '+destpath)

yaml_template = """#
# SOWFA precursor template generated by sowfa_precursor_setup.py
# github.com/ewquon/lazboy
#

# domain controls
xMin: {xMin:f}  # Minimum x-extent of domain (m).
yMin: {yMin:f}  # Minimum y-extent of domain (m).
zMin: {zMin:f}  # Minimum z-extent of domain (m).
xMax: {xMax:f}  # Maximum x-extent of domain (m).
yMax: {yMax:f}  # Maximum y-extent of domain (m).
zMax: {zMax:f}  # Maximum z-extent of domain (m).
nx: {nx:d}  # Number of cells in x-direction.
ny: {ny:d}  # Number of cells in y-direction.
nz: {nz:d}  # Number of cells in z-direction.


# decomposition controls
PPN: {PPN:d}  # Processors per node
nCores: {nCores:d}  # Number of cores on which to run this case.
decompType: {decompType:s}  # Decomposition algorithm.  "simple" and "scotch" are good choices.
decompOrder: [{decompOrder[0]:d}, {decompOrder[1]:d}, {decompOrder[2]:d}] # Order of the decomposition number of partitions in (x y z)-directions.


# general conditions
TRef: {TRef:f}  # Reference potential temperature (K).
coriolis: {coriolis}
latitude: {latitude:f}  # Latitude on the Earth of the site (deg).
EarthPeriod: {EarthPeriod:f}  # Earth's rotation period (hr).


# atmosphere controls
velocityInitType: {velocityInitType:s}  # How to initialize the base velocity profile (geostrophic, log, table)
temperatureInitType: {temperatureInitType:s}  # How to initialize the base temperature profile (simple, table)
U0Mag: {U0Mag:f}  # Initial condition for wind speed (m/s).
dir: {dir:f}  # Initial condition for wind direction (deg).
windHeight: {windHeight:f}  # Height at which to drive mean wind to U0Mag/dir (m).
p_rgh0: {p_rgh0:f}  # Initial pressure (minus the hydrostatic variation and normalized by density) (m^2/s^2).
nuSgs0: {nuSgs0:f}  # Initial SGS viscosity (m^2/s).
k0: {k0:f}  # Initial SGS turbulent kinetic energy (m^2/s^2).
kappat0: {kappat0:f}  # Initial SGS temperature diffusivity (m^2/s).
TGradUpper: {TGradUpper:f}  # Potential temperature gradient above the strong inversion (K/m).
zInversion: {zInversion:f}  # Height of the middle of the initial strong capping inversion (m).
inversionWidth: {inversionWidth:f}  # Vertical width of the intial strong capping inversion (m).
TBottom: {TBottom:f}  # Initial potential temperature at bottom of strong capping inversion (K).
TTop: {TTop:f}  # Initial potential temperature at top of strong capping inversion (K).

sourceType: {sourceType:s}
idealProfile: {idealProfile}
alpha: {alpha:f}  # Shear exponent, not used if idealProfile is False.
veer: {veer:f}  # Veer (deg), not used if idealProfile is False.
profileTable: {profileTable}


# surface controls
surfaceBCType: {surfaceBCType:s}
qwall: {qwall:f}  # Temperature flux at wall (modify the z-value).  A negative value is flux into domain (K-m/s).
Rwall: {Rwall}  # Initial wall shear stress (m^2/s^2).
kappa: {kappa:f}  # von Karman constant.
z0: {z0:f}  # Surface roughness (m).
heatingRate: {heatingRate:e}  # Surface temperature change rate (when not directly setting temperature flux) (K/s).


# advanced settings

# -surface conditions
wallModelAverageType: {wallModelAverageType:s}  # Treat surface stress wall model locally ("local") or with planar averaging ("planarAverage").
betaM: {betaM:f}  # Monin-Obukhov wall shear stress model constant.
gammaM: {gammaM:f}  # Monin-Obukhov wall shear stress model constant.
betaH: {betaH:f}  # Monin-Obukhov wall temperature flux model constant.
gammaH: {gammaH:f}  # Monin-Obukhov wall temperature flux model constant.
alphaH: {alphaH:f}  # Monin-Obukhov wall temperature flux model constant.

# -planar averaging and source term statistics options.
statisticsOn: {statisticsOn}  # Gather planar-averaged flow statistics.
statisticsFrequency: {statisticsFrequency:d}  # Frequency in time steps of statistics gathering.

# -transport properties
Pr: {Pr:f}  # Molecular Prandtl number.
Prt: {Prt:f}  # Turbulent Prandtl number.
nu: {nu:e}  # Molecular viscosity (m^2/s).

# -SGS model inputs
LESModel: {LESModel:s}  # SGS model selection.
ce: {ce:e}  # SGS model constant.
ck: {ck:e}  # SGS model constant.
"""

